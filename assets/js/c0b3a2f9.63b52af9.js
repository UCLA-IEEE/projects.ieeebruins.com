"use strict";(self.webpackChunkprojects_ieeebruins_com=self.webpackChunkprojects_ieeebruins_com||[]).push([[410],{9967:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var i=n(5893),s=n(1151);const o={},r="Lab 1",l={id:"DAV/lab-1",title:"Lab 1",description:"Cooking Math",source:"@site/docs/DAV/lab-1.md",sourceDirName:"DAV",slug:"/DAV/lab-1",permalink:"/DAV/lab-1",draft:!1,unlisted:!1,editUrl:"https://github.com/UCLA-IEEE/projects.ieeebruins.com/tree/main/docs/DAV/lab-1.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"DAV",permalink:"/DAV/"},next:{title:"Lab 2",permalink:"/DAV/lab-2"}},a={},h=[{value:"Cooking Math",id:"cooking-math",level:3},{value:"Introduction",id:"introduction",level:2},{value:"Resources and Reference Material",id:"resources-and-reference-material",level:2},{value:"Contact Us",id:"contact-us",level:2},{value:"0 Your First Module",id:"0-your-first-module",level:2},{value:"0.1 The Top Level",id:"01-the-top-level",level:3},{value:"0.2 The Testbench",id:"02-the-testbench",level:3},{value:"0.3 Pin Planning",id:"03-pin-planning",level:3},{value:"1 Is That ALU Can Say?",id:"1-is-that-alu-can-say",level:2},{value:"1.1 The (mini) ALU",id:"11-the-mini-alu",level:3},{value:"1.2 The Testbench (again)",id:"12-the-testbench-again",level:3},{value:"2 \u2018Twas Segment to Be",id:"2-twas-segment-to-be",level:2},{value:"2.1 The Seven-Segment Digit",id:"21-the-seven-segment-digit",level:3},{value:"2.2 The Seven-Segment Display",id:"22-the-seven-segment-display",level:3}];function d(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"lab-1",children:"Lab 1"}),"\n",(0,i.jsx)(t.h3,{id:"cooking-math",children:"Cooking Math"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"#0-your-first-module",children:"0 Your First Module"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#01-the-top-level",children:"0.1 The Top Level"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#02-the-testbench",children:"0.2 The Testbench"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#03-pin-planning",children:"0.3 Pin Planning"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"#1-is-that-alu-can-say",children:"1 Is That ALU Can Say?"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#11-the-mini-alu",children:"1.1 The (mini) ALU"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#12-the-testbench-again",children:"1.2 The Testbench (again)"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"#2-twas-segment-to-be",children:"2 'Twas Segment to Be"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#21-the-seven-segment-digit",children:"2.1 The Seven-Segment Digit"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#22-the-seven-segment-display",children:"2.2 The Seven-Segment Display"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(t.p,{children:"Welcome to DAV! By this point, you\u2019ve probably attended or watched the first lecture where we talked about the project and gave a high-level conceptual overview of logic design. Now, it\u2019s time to try your hand at Verilog for the first time by making a (very) basic calculator on your FPGA. In the digital world, we refer to such circuits as \u201carithmetic logic units,\u201d or ALUs."}),"\n",(0,i.jsx)(t.h2,{id:"resources-and-reference-material",children:"Resources and Reference Material"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://drive.google.com/file/d/16LD_dYyo49NGHnih-ArGze99MuCCs8L4/view?usp=share_link",children:"Link to Lecture 1"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://drive.google.com/file/d/12Pz_-xRepHj60k03G1PzrEOOhTwyxwga/view?usp=drive_link",children:"Link to Workshop 1"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://docs.google.com/spreadsheets/d/1jTgphR61ozrNZlr9dLvId5t3o0FrikxSZWwAvhXF0Yo/edit#gid=0",children:"Pin Sheet"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://docs.google.com/document/d/1_8ruatZIb3sZb-3Kk3WOYC8Jzv4HvdwrTPZUGVupdVE/edit",children:"Verilog Docs and FAQ"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/amidthestars/DAV-Outreach-Module-Solutions",children:"Solution"})}),"\n",(0,i.jsx)(t.h2,{id:"contact-us",children:"Contact Us"}),"\n",(0,i.jsx)(t.p,{children:"You can contact the DAV leads on Discord."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Claire Huang"})," (Discord: ",(0,i.jsx)(t.em,{children:"zhiyujia"}),")",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.strong,{children:"Premkumar Giridhar"})," (Discord: ",(0,i.jsx)(t.em,{children:"8bitrobot"}),")"]}),"\n",(0,i.jsx)(t.h2,{id:"0-your-first-module",children:"0 Your First Module"}),"\n",(0,i.jsx)(t.p,{children:"Your first module for the FPGA calculator will be a very basic top-level module. As we go on, we\u2019ll add things to this module, but for now your task is to control the LEDs with the switches in a very specific way: each switch will light up the LED directly above it."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Section 0"})," of this lab will be completed ",(0,i.jsx)(t.strong,{children:"live during the workshop"})," and the code will be made available. However, if you can\u2019t make it or you want to try it yourself, you\u2019ll have access to a recording that you can use to work through the lab. There will be ",(0,i.jsx)(t.strong,{children:"no checkoffs"})," for this section of the lab; however, you\u2019ll still need to show us your working LEDs, so make sure you get it done! This part of the lab is by no means difficult; it\u2019s simply an opportunity to become more familiar with Quartus."]}),"\n",(0,i.jsx)(t.h3,{id:"01-the-top-level",children:"0.1 The Top Level"}),"\n",(0,i.jsxs)(t.p,{children:["Firstly, ",(0,i.jsx)(t.strong,{children:"create a new project"})," \u2013 instructions are in the workshop slides. Then, ",(0,i.jsx)(t.strong,{children:"create a file"})," named ",(0,i.jsx)(t.code,{children:"miniALU_top.sv"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Inside, you need to define the module and its ports \u2013 the syntax is provided in the Verilog docs linked at the top of the spec. We want our FPGA to process the ",(0,i.jsx)(t.strong,{children:"switches as inputs"})," and produce ",(0,i.jsx)(t.strong,{children:"outputs on the LEDs"}),". There are 10 switches and 10 LEDs, each representing a single binary value (up or down, on or off). Think about what ports you need to define to allow the module to use them. (If you feel like you need to define 20 individual ports, rest assured that it\u2019s unnecessary. There\u2019s a better way to consolidate those ports together!)"]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, now that you have your ports, you need to somehow \u201cconnect\u201d the switches to the LEDs. There\u2019s a ",(0,i.jsx)(t.strong,{children:"single Verilog statement"})," you can use for connecting wires in the manner described above \u2013 if you can\u2019t figure it out, refer to our docs!"]}),"\n",(0,i.jsx)(t.p,{children:"That\u2019s all there is to it! This module should be at most 10 lines long. Next, you\u2019ll determine whether it actually works."}),"\n",(0,i.jsx)(t.h3,{id:"02-the-testbench",children:"0.2 The Testbench"}),"\n",(0,i.jsxs)(t.p,{children:["That\u2019s right, it\u2019s time for everyone\u2019s favorite part of digital design: testbenching! Let\u2019s write a testbench that confirms that our switch input gets mapped correctly to our LED output. Create a file named ",(0,i.jsx)(t.code,{children:"miniALU_tb.sv"})," and set it as the top-level module."]}),"\n",(0,i.jsxs)(t.p,{children:["A testbench, like any other module, uses the ",(0,i.jsx)(t.code,{children:"module/endmodule"})," syntax for declaration. However, as the first line of any testbench, you must include the following line:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-verilog",children:"timescale 1ns/1ns\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This is a directive that QuestaSim, our simulation software, uses to determine the duration of \u201csimulation time\u201d units relative to \u201cdelay time\u201d units, as well as a degree of precision. The details aren\u2019t too important right now, so you can just copy-paste as written above. If you\u2019re curious and want to read more, ",(0,i.jsx)(t.a,{href:"https://www.chipverify.com/verilog/verilog-timescale",children:"click here"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Define a module"})," named ",(0,i.jsx)(t.code,{children:"miniALU_tb"})," that has ",(0,i.jsx)(t.strong,{children:"no input ports"})," and whose ",(0,i.jsx)(t.strong,{children:"outputs are the LEDs"}),". (Like before, you don\u2019t need 10 ports for this.) You\u2019ll need to create a ",(0,i.jsx)(t.code,{children:"reg"})," for your simulated switches. Inside the module, instantiate ",(0,i.jsx)(t.code,{children:"miniALU_top"})," and pass in your switches and LED output port accordingly."]}),"\n",(0,i.jsxs)(t.p,{children:["Remember that testbenches are less like digital circuit modules and more like simple scripts. Verilog code inside the ",(0,i.jsx)(t.code,{children:"initial"})," block runs **sequentially **and the timing is determined by your use of delays. The workshop will go into more detail about what exactly this means and how to use these delays and the ",(0,i.jsx)(t.code,{children:"initial"})," block to write a testbench. Though you don\u2019t need to submit anything here for checkoffs, you\u2019ll be writing your own testbench later on, so ask us questions if you don\u2019t understand it!"]}),"\n",(0,i.jsx)(t.h3,{id:"03-pin-planning",children:"0.3 Pin Planning"}),"\n",(0,i.jsxs)(t.p,{children:["Now that you\u2019ve verified your design in simulation, it\u2019s time to upload it to the FPGA and see if it really works. Set ",(0,i.jsx)(t.code,{children:"miniALU_top.sv"})," as the top level and run Synthesis again."]}),"\n",(0,i.jsxs)(t.p,{children:["Now, open the Pin Planner. It should list your top-level I/O ports at the bottom below a large grid of colors and shapes. Ignore the grid and refer to the ",(0,i.jsx)(t.a,{href:"https://docs.google.com/spreadsheets/d/1jTgphR61ozrNZlr9dLvId5t3o0FrikxSZWwAvhXF0Yo/edit#gid=0",children:"Pin Sheet"})," to map your pins. More detailed instructions are provided in the workshop."]}),"\n",(0,i.jsx)(t.p,{children:"Once you\u2019ve done that, run the Fitter and Assembler, then program your FPGA. If all is well, each switch should be able to control the LED above it!"}),"\n",(0,i.jsx)(t.h2,{id:"1-is-that-alu-can-say",children:"1 Is That ALU Can Say?"}),"\n",(0,i.jsxs)(t.p,{children:["This section of the lab will teach you how to implement the core module that will perform the calculations: ",(0,i.jsx)(t.strong,{children:"the Arithmetic Logic Unit, or ALU"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"11-the-mini-alu",children:"1.1 The (mini) ALU"}),"\n",(0,i.jsxs)(t.p,{children:["In this module, you\u2019ll implement a very **basic ALU **that performs two operations. It will take two ",(0,i.jsx)(t.strong,{children:"4-bit numbers"})," and a ",(0,i.jsx)(t.strong,{children:"select line as input"})," and produce a single ",(0,i.jsx)(t.strong,{children:"20-bit number as output"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Your ALU will ",(0,i.jsx)(t.strong,{children:"use the switches"})," as indicated below:"]}),"\n",(0,i.jsx)(t.p,{children:'![An image of ten switches on an FPGA. The first four from the left are underlined in red as operand1, a 4 bit number. The next four are underlined as operand2, also 4 bits. The next switch (second from the right) is marked as the select switch.] (images/image12.png "image_tooltip")'}),"\n",(0,i.jsxs)(t.p,{children:["The select switch will dictate whether the ALU operation is an ",(0,i.jsx)(t.strong,{children:"addition"})," (i.e. when ",(0,i.jsx)(t.code,{children:"select"})," is HIGH, output ",(0,i.jsx)(t.strong,{children:"operand1 + operand2"}),") or a left-shift (when ",(0,i.jsx)(t.code,{children:"select"})," is LOW, output ",(0,i.jsx)(t.strong,{children:"operand1 << operand2"}),"). There\u2019s a commonly used hardware block (and a related Verilog construct) that allows you to select between two or more values based on a boolean condition; do you remember what it is? (Hint: It was mentioned in the lecture!)"]}),"\n",(0,i.jsxs)(t.p,{children:["The file ",(0,i.jsx)(t.code,{children:"miniALU.sv"})," contains skeleton code including a module declaration and an empty ",(0,i.jsx)(t.code,{children:"always_comb"})," construct, which we use to describe a combinational circuit.. Your task is to declare the module\u2019s ports and fill out the ",(0,i.jsx)(t.code,{children:"always"})," block to complete the module."]}),"\n",(0,i.jsx)(t.h3,{id:"12-the-testbench-again",children:"1.2 The Testbench (again)"}),"\n",(0,i.jsx)(t.p,{children:"I hope you didn\u2019t think we\u2019d let you get away without writing a testbench! Here, we\u2019ll modify our testbench from earlier to test our ALU module. Consider the following:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"You will have more regs in this testbench because the module being tested takes in more inputs."}),"\n",(0,i.jsxs)(t.li,{children:["It won\u2019t suffice to simply test a couple cases \u2013 after all, your ALU has two modes and many more combinations of operands. You could code in tons of cases manually, but there\u2019s an easier way: the Verilog ",(0,i.jsx)(t.code,{children:"for"}),"-loop!"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-verilog",children:"for (integer i = 0; i < 16; i = i + 1) begin\n    #5; // simulation delay\n    /* YOUR CODE HERE */\nend\n"})}),"\n",(0,i.jsx)(t.p,{children:"Consider using this as a template to write a for-loop that iterates through a large set of test-cases."}),"\n",(0,i.jsx)(t.h2,{id:"2-twas-segment-to-be",children:"2 \u2018Twas Segment to Be"}),"\n",(0,i.jsxs)(t.p,{children:["In this part of the lab, you will implement a seven-segment decoder. In other words, your module will take as ",(0,i.jsx)(t.strong,{children:"input a 20-bit number"})," and produce as ",(0,i.jsx)(t.strong,{children:"output a set of 8-bit numbers"})," indicating the values of each segment of each digit. We\u2019ll break this task down into two modules."]}),"\n",(0,i.jsx)(t.h3,{id:"21-the-seven-segment-digit",children:"2.1 The Seven-Segment Digit"}),"\n",(0,i.jsxs)(t.p,{children:["Each digit of the seven-segment display of the FPGA requires 8 bits to drive: 7 bits for the segments and an additional bit for the decimal point. This module, which we\u2019ll call ",(0,i.jsx)(t.code,{children:"sevenSegDigit"}),", accepts a ",(0,i.jsx)(t.strong,{children:"4-bit number"})," and a ",(0,i.jsx)(t.strong,{children:"1-bit on/off switch as input"})," and ",(0,i.jsx)(t.strong,{children:"output an 8-bit number"})," for the segments."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"A picture of a seven-segment display unit in the shape of an 8. 0 represents the top segment, 1 represents the top right segment, 2 represents the bottom right segment, 3 represents the bottom segment, 4 represents the bottom left segment, 5 represents the bottom right segment, and 6 represents the middle segment.",src:n(5119).Z+"",width:"306",height:"460"})}),"\n",(0,i.jsx)(t.p,{children:"The segments in each digit are represented by the picture shown here. In other words, \u201cbit 0\u201d (i.e. the LSB) in your 8-bit number should represent the top segment, bit 1 should represent the top-right, etc. Pay careful attention to your indexing when you assign to these segments."}),"\n",(0,i.jsxs)(t.p,{children:["Also note that the segments are active-low, meaning that a value of ",(0,i.jsx)(t.strong,{children:"1 will turn the segment off"})," and ",(0,i.jsx)(t.strong,{children:"0 will turn it on"}),". This is a very common source of errors!"]}),"\n",(0,i.jsxs)(t.p,{children:["This module\u2019s logic is simple: there are 10 digits, each one mapping to a distinct set of segments. Therefore, you can use a construct called a ",(0,i.jsxs)(t.strong,{children:[(0,i.jsx)(t.code,{children:"case"}),"-statement"]})," that looks like the ",(0,i.jsx)(t.code,{children:"switch-case"})," statement you might have seen in other programming languages. Your case statement will compare the input to each of the 10 digits and produce a \u201cdefault\u201d output if none of them match \u2013 ",(0,i.jsx)(t.strong,{children:"this is required"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Since we\u2019re no longer working with simple operations or ",(0,i.jsx)(t.code,{children:"assign"})," statements, you will need an ",(0,i.jsx)(t.code,{children:"always"})," construct to contain your combinational logic. The skeleton code in ",(0,i.jsx)(t.code,{children:"sevenSegDigit.sv"})," contains an ",(0,i.jsx)(t.code,{children:"always"})," construct and some ",(0,i.jsx)(t.code,{children:"case"}),"-statement syntax. Your task now is to ",(0,i.jsx)(t.strong,{children:"complete this module"})," by adding a module declaration, port list, and finished ",(0,i.jsx)(t.code,{children:"case"}),"-statement. When finished, it should correctly output the seven-segment bits for any input number from 0 to 9. If the on/off switch is off, all of the segments should be unlit."]}),"\n",(0,i.jsx)(t.h3,{id:"22-the-seven-segment-display",children:"2.2 The Seven-Segment Display"}),"\n",(0,i.jsxs)(t.p,{children:["Of course, one digit alone doesn\u2019t accomplish very much because most numbers are more than one digit. Therefore, we will now write a module that ",(0,i.jsx)(t.strong,{children:"decodes a much larger 20-bit number"})," into 6 sets of segments. As before, a skeleton file has been provided \u2013 ",(0,i.jsx)(t.code,{children:"sevenSegDisplay.sv"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The logic for this module is simple because you\u2019ve already written the decoder for one individual digit. You don\u2019t have to write that logic again; you can simply instantiate a few copies of that module to decode each of the 6 digits in the number."}),"\n",(0,i.jsxs)(t.p,{children:["That being said, your focus for this module is implementing a ",(0,i.jsx)(t.strong,{children:"circuit that converts a 20-bit number into six 4-bit numbers"}),", one for each digit. Then, you should use ",(0,i.jsx)(t.code,{children:"sevenSegDigit"})," to convert these 4-bit numbers into the ",(0,i.jsx)(t.strong,{children:"8-bit segment arrays"}),"; ",(0,i.jsx)(t.strong,{children:"these will be your outputs"}),". How might you do this? Think about the arithmetic operators you have available to you in Verilog and which ones are useful for extracting digits from a number."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, you need to instantiate this module in ",(0,i.jsx)(t.code,{children:"miniALU_top"})," and wire up the ports as follows:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The first operand input to the mini ALU is the first 4 switches (as labeled in the image from earlier)."}),"\n",(0,i.jsx)(t.li,{children:"The second operand input to the mini ALU is the second 4 switches (as labeled in the image from earlier)."}),"\n",(0,i.jsx)(t.li,{children:"The \u201cmode\u201d select input to the mini ALU is the ninth switch (as labeled in the image from earlier)."}),"\n",(0,i.jsx)(t.li,{children:"The 20-bit number input to the seven-segment display module is the output of the mini ALU."}),"\n",(0,i.jsx)(t.li,{children:"The on/off switch input to the seven-segment display is the 10th (unused) switch on the FPGA."}),"\n",(0,i.jsx)(t.li,{children:"The output of the seven-segment display module is the output of the top level module (which gets mapped to the segmented display on the FPGA)."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This will also require you to pin-plan! When it\u2019s all done, you should be able to use the switches to display your calculation results on the FPGA. ",(0,i.jsx)(t.strong,{children:"Don\u2019t delete your earlier LED code when doing this!"})," Your modules are allowed to have more than one output."]}),"\n",(0,i.jsx)(t.p,{children:"The end result will be your FPGA displaying the switches\u2019 values on the LEDs and the mathematical result on the seven-segment display. Changing the switches should immediately change the displayed number, as should toggling the 9th switch to change the mathematical operation; and toggling that very last switch should turn the display on or off."})]})}function c(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},5119:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/image11-6df01097a6ddc57ba9a852a6eb4c070e.png"},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>r});var i=n(7294);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);