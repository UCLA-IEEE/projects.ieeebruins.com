"use strict";(self.webpackChunkprojects_ieeebruins_com=self.webpackChunkprojects_ieeebruins_com||[]).push([[200],{7012:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var i=n(5893),s=n(1151);const o={},r="Lab 2",l={id:"DAV/lab-2",title:"Lab 2",description:"Clocked and Loaded",source:"@site/docs/DAV/lab-2.md",sourceDirName:"DAV",slug:"/DAV/lab-2",permalink:"/DAV/lab-2",draft:!1,unlisted:!1,editUrl:"https://github.com/UCLA-IEEE/projects.ieeebruins.com/tree/main/docs/DAV/lab-2.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Lab 1",permalink:"/DAV/lab-1"},next:{title:"Lab 3",permalink:"/DAV/lab-3"}},a={},h=[{value:"Clocked and Loaded",id:"clocked-and-loaded",level:3},{value:"Introduction",id:"introduction",level:2},{value:"Resources and Reference Material",id:"resources-and-reference-material",level:2},{value:"Contact Us",id:"contact-us",level:2},{value:"0 A World Divided",id:"0-a-world-divided",level:2},{value:"0.1 The Clock Divider",id:"01-the-clock-divider",level:3},{value:"0.2 Testing the Clock Divider",id:"02-testing-the-clock-divider",level:3},{value:"0.3 General Tips",id:"03-general-tips",level:3},{value:"1 Let\u2019s Get This Bread",id:"1-lets-get-this-bread",level:2},{value:"1.1 Using a Breadboard",id:"11-using-a-breadboard",level:3},{value:"1.2 Buzzers and Frequencies",id:"12-buzzers-and-frequencies",level:3},{value:"2 An Alarming Rate",id:"2-an-alarming-rate",level:2},{value:"2.1 The Block Diagram",id:"21-the-block-diagram",level:3},{value:"2.2 The Finite State Machine",id:"22-the-finite-state-machine",level:3},{value:"3 It\u2019s About Time",id:"3-its-about-time",level:2},{value:"3.1 Implementing an FSM",id:"31-implementing-an-fsm",level:3}];function d(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"lab-2",children:"Lab 2"}),"\n",(0,i.jsx)(t.h3,{id:"clocked-and-loaded",children:"Clocked and Loaded"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"#0-a-world-divided",children:"0: A World Divided"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#01-the-clock-divider",children:"0.1: The Clock Divider"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#02-testing-the-clock-divider",children:"0.2: Testing the Clock Divider"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#03-general-tips",children:"0.3: General Tips"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"#1-lets-get-this-bread",children:"1: Let's Get This Bread"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#11-using-a-breadboard",children:"1.1: Using a Breadboard"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#12-buzzers-and-frequencies",children:"1.2: Buzzers and Frequencies"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"#2-an-alarming-rate",children:"2: An Alarming Rate"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#21-the-block-diagram",children:"2.1: The Block Diagram"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#22-the-finite-state-machine",children:"2.2: The Finite State Machine"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"#3-its-about-time",children:"3: It's About Time"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#31-implementing-an-fsm",children:"3.1: Implementing an FSM"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(t.p,{children:"In Lecture 2, you learned about all of the components behind sequential logic. You started from the base gate level, using latches to make flip flops, and flip flops to make registers. You learned about clocks and finite state machines. It\u2019s time to put that knowledge into practice and make an alarm clock with a working buzzer!"}),"\n",(0,i.jsx)(t.h2,{id:"resources-and-reference-material",children:"Resources and Reference Material"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://drive.google.com/file/d/1agTteJ9prdds06XiEAn1TJsO8yg0_HXP/view?usp=drive_link",children:"Link to Lecture 2"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://docs.google.com/spreadsheets/d/1jTgphR61ozrNZlr9dLvId5t3o0FrikxSZWwAvhXF0Yo/edit#gid=0",children:"Pin Sheet"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://docs.google.com/document/d/1_8ruatZIb3sZb-3Kk3WOYC8Jzv4HvdwrTPZUGVupdVE/edit",children:"Verilog Docs and FAQ"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/amidthestars/DAV-Outreach-Module-Solutions",children:"Solution"})}),"\n",(0,i.jsx)(t.h2,{id:"contact-us",children:"Contact Us"}),"\n",(0,i.jsx)(t.p,{children:"You can contact the DAV leads on Discord."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Claire Huang"})," (Discord: ",(0,i.jsx)(t.em,{children:"zhiyujia"}),")",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.strong,{children:"Premkumar Giridhar"})," (Discord: ",(0,i.jsx)(t.em,{children:"8bitrobot"}),")"]}),"\n",(0,i.jsx)(t.h2,{id:"0-a-world-divided",children:"0 A World Divided"}),"\n",(0,i.jsx)(t.p,{children:"In this section of the lab, you\u2019ll be making a clock divider and learning about best practices when writing reusable Verilog modules."}),"\n",(0,i.jsx)(t.h3,{id:"01-the-clock-divider",children:"0.1 The Clock Divider"}),"\n",(0,i.jsxs)(t.p,{children:["For this lab, you\u2019ll need a clock divider. A basic clock divider circuit was covered in the lecture, but now we want to make it better. The goal of this is to give you a customizable clock divider that you can use forever and ever. How do we do that? With ",(0,i.jsx)(t.strong,{children:"parameters"}),"! Refer to the Verilog Docs and FAQ (linked above) to see how and why we do this."]}),"\n",(0,i.jsxs)(t.p,{children:["In this case, your FPGA has a 50 MHz clock on it that you\u2019ll divide into many smaller clocks \u2013 so ",(0,i.jsx)(t.strong,{children:"50000000"})," would be your parameter\u2019s ",(0,i.jsx)(t.strong,{children:"default value"}),". But if you want to divide a different clock, specify that clock\u2019s speed as the parameter value."]}),"\n",(0,i.jsxs)(t.p,{children:["You might be wondering: why don\u2019t we use a parameter for the clock ",(0,i.jsx)(t.em,{children:"speed"}),"? Consider that parameters are computed during synthesis (i.e. at compile-time) and not when the circuit is running. If we want to vary the speed of the stopwatch using a switch, we need to use an input to the clock divider module that actually gets computed while the circuit is active."]}),"\n",(0,i.jsxs)(t.p,{children:["So let\u2019s add a variable clock speed to our clock dividers \u2013 it\u2019s as simple as passing in a ",(0,i.jsx)(t.code,{children:"speed"})," input. Be careful with how you drive your output clock, though, because an output clock that is generated ",(0,i.jsx)(t.em,{children:"combinationally"})," will cause ",(0,i.jsx)(t.strong,{children:"timing violations"}),"; you should be updating a register that drives an output from the module so that your output is updated in sync with the input clock."]}),"\n",(0,i.jsx)(t.p,{children:"All that being said, here\u2019s the \u201cspec\u201d for your clock divider:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Your clock divider should accept an input ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"clk"})}),", a ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"speed"})})," value in Hz, and a ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"reset"})})," button as inputs. Its sole output should be an output ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"outClk"})}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Your clock divider should also have a parameter ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"BASE_SPEED"})})," with a default value of ",(0,i.jsx)(t.strong,{children:"50000000"})," to indicate that the default base clock speed will be 50000000 Hz, or ",(0,i.jsx)(t.strong,{children:"50 MHz"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["We tend to use this clock divider module for slower clocks where accuracy isn\u2019t a high concern, so your speed input should only have enough bits to indicate a clock speed of at most ",(0,i.jsx)(t.strong,{children:"1 MHz"}),". You should think about how much that is in Hz and calculate the number of bits appropriately. (There\u2019s a neat trick to finding that number of bits \u2013 see if you can find it in ",(0,i.jsx)(t.a,{href:"https://docs.google.com/document/d_8ruatZIb3sZb-3Kk3WOYC8Jzv4HvdwrTPZUGVupdVE/edit",children:"Verilog Docs and FAQ"}),"!)"]}),"\n",(0,i.jsxs)(t.li,{children:["As we discussed in lecture, the clock divider uses a counter to determine when to flip the clock. The counter\u2019s maximum value is simply your division ratio \u2013 if your base clock is 16 Hz and your output speed is 4 Hz, your counter should increment every clock cycle but never exceed ",(0,i.jsx)(t.strong,{children:"3"})," , i.e. ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"(BASE_SPEED / speed) - 1"})}),".","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"We subtract 1 here because the counter range starts at 0, meaning that a clock period spans 0 to 3 \u2013 a total of 4 clock cycles."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["This module will require both a sequential block and a combinational block. Recall that when we write sequential circuits, we try to keep our logic contained in the combinational block as much as possible, and we reserve the sequential block for synchronously assigning values.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["In the ",(0,i.jsx)(t.strong,{children:"combinational block"}),", you will determine what the value of your output clock will be for the next clock cycle. If the reset button is pressed, set the output clock to 0. If the counter is less than halfway up to the maximum value, i.e. less than or equal to 1 in the example above, also set the output clock to 0. Otherwise, set it to 1. This will ensure a ",(0,i.jsx)(t.strong,{children:"50% duty cycle"}),"; most of our peripherals (including the buzzer) are only happy at 50%, so in general you should pick that as your output clock\u2019s duty cycle of choice.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["A common industry standard naming convention is ",(0,i.jsx)(t.code,{children:"regName_d"})," to indicate the value of ",(0,i.jsx)(t.code,{children:"regName"})," on the following clock cycle."]})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Also in the ",(0,i.jsx)(t.strong,{children:"combinational block"}),", you will determine the next value of your counter. If the reset button is pressed or the counter is at the maximum value as determined by your division factor, the new value of the counter should be 0. Otherwise, it should be the previous counter value incremented by 1."]}),"\n",(0,i.jsxs)(t.li,{children:["In the ",(0,i.jsx)(t.strong,{children:"sequential block"}),", you should update the values of your ",(0,i.jsx)(t.strong,{children:"output clock register"})," and your ",(0,i.jsx)(t.strong,{children:"counter"}),". The \u201cnew values\u201d of each one should be calculated in the combinational block."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"02-testing-the-clock-divider",children:"0.2 Testing the Clock Divider"}),"\n",(0,i.jsx)(t.p,{children:"Now, how do we test our clock dividers? (You\u2019re testing your clock dividers, right? Right??)"}),"\n",(0,i.jsx)(t.p,{children:"We\u2019ll make a testbench for them!"}),"\n",(0,i.jsxs)(t.p,{children:["You can test this by creating a 1 bit clock register in a testbench. In an ",(0,i.jsxs)(t.strong,{children:[(0,i.jsx)(t.code,{children:"always"})," block"]})," (with NO sensitivity list!), you can flip this clock register every few simulated nanoseconds."]}),"\n",(0,i.jsx)(t.p,{children:"However, this simulation will go on forever! There\u2019s two ways to stop it \u2013 one in Questa, and one in the testbench. In Questa, when the simulation is simulating, you can just click \u201cBreak\u201d from the Simulate menu where you hit \u201cRun.\u201d But alternatively, in your testbench code, you can do something like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-verilog",children:"initial begin // we run this block once when execution begins\n    clock = 0;    // initialize the clock\n    #10000 $stop; // after 10000 time ticks, we end simulation.\nend\nalways begin // always w/ no sensitivity only works in simulation\n    #10 clock = ~clock; // we toggle the clock every 10 nanoseconds\n                        // this runs in parallel to the initial\n                        // block, so it will stop after 10000\n                        // nanoseconds\nend\n"})}),"\n",(0,i.jsx)(t.h3,{id:"03-general-tips",children:"0.3 General Tips"}),"\n",(0,i.jsx)(t.p,{children:"Ideally, all of you would leave DAV knowing how to write decent modules, so here are some other things to look out for. These tips are important both for the clock divider and for the rest of the lab."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Make sure your design doesn\u2019t have any ",(0,i.jsx)(t.strong,{children:"inferred latches"}),"! This means that your combinational logic is ",(0,i.jsx)(t.strong,{children:"not purely combinational"})," \u2013 some logical error is leading the synthesis tool to think you want memory. This also means that your logic probably isn\u2019t doing what you wanted it to be.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["You can catch these by using the ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"always_comb"})})," block for your combinational logic instead of ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"always @(*)"})})," \u2013 it\u2019s a SystemVerilog-exclusive block that triggers synthesis errors when latches are inferred in a combinational circuit."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Your sequential logic should be triggered, well, sequentially! It should be triggered ",(0,i.jsx)(t.strong,{children:"on a clock"})," and not an arbitrary signal (like a button or switch)."]}),"\n",(0,i.jsxs)(t.li,{children:["For finite state machines, the next state generation should be ",(0,i.jsx)(t.strong,{children:"combinational"}),", while the actual state change event should be ",(0,i.jsx)(t.strong,{children:"sequential"}),".","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The logic that determines the next state should be in a ",(0,i.jsxs)(t.strong,{children:[(0,i.jsx)(t.code,{children:"case"}),"-statement"]}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Remember to use ",(0,i.jsx)(t.strong,{children:"non-blocking"})," assignment in sequential logic blocks!"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"1-lets-get-this-bread",children:"1 Let\u2019s Get This Bread"}),"\n",(0,i.jsxs)(t.p,{children:["We\u2019re going to use a breadboard to set up our buzzer! If you know how breadboards work, you can skip to ",(0,i.jsx)(t.a,{href:"#1-2-buzzers-and-frequencies",children:"Buzzers and Frequencies"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"11-using-a-breadboard",children:"1.1 Using a Breadboard"}),"\n",(0,i.jsx)(t.p,{children:"For those who have never touched a breadboard, here\u2019s a quick introduction."}),"\n",(0,i.jsx)(t.p,{children:"Here\u2019s a picture of a breadboard. For our purposes, we can ignore the areas between the - and + on either side. (If you\u2019re curious, those would be for if you wanted to attach batteries or power sources.)"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"A diagram of a breadboard.",src:n(3325).Z+"",width:"300",height:"469"})}),"\n",(0,i.jsx)(t.p,{children:"What we want to observe is the pins in the middle. We\u2019ll refer to the A-J lines as \u201ccolumns\u201d and the 1-30 lines as \u201crows.\u201d (A2 would be column A, row 2). Notice the yellow lines connecting everything row-wise? If we want to connect something in series, we would want to connect them using pins in the same row. That\u2019s all we\u2019ll need for the purposes of DAV. (For reference, connecting things across columns would be connecting them in parallel.)"}),"\n",(0,i.jsx)(t.p,{children:"For the buzzer, make sure when you wire it to one of the FPGA pins of your choice, you connect it across the row!"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Remember to connect one side of the buzzer to ground!"})," Refer to its datasheet to determine which side to connect to ground. (Or, if it's not polarized, simply connect either one.)"]}),"\n",(0,i.jsx)(t.h3,{id:"12-buzzers-and-frequencies",children:"1.2 Buzzers and Frequencies"}),"\n",(0,i.jsx)(t.p,{children:"The buzzer just needs an oscillating signal to make noise - a clock, for example. Remember how all notes are frequencies? You can look up a note that you want your buzzer to buzz at and find the frequency it needs. You can then generate a clock at that frequency using your clock divider and pass that clock to the output pin, which will be wired to your buzzer!"}),"\n",(0,i.jsx)(t.h2,{id:"2-an-alarming-rate",children:"2 An Alarming Rate"}),"\n",(0,i.jsxs)(t.p,{children:["It\u2019s time to get to the actual lab! In this lab, you\u2019ll be making an ",(0,i.jsx)(t.strong,{children:"alarm clock"}),". The inputs will be:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"a start/stop button"}),"\n",(0,i.jsx)(t.li,{children:"a reset button"}),"\n",(0,i.jsx)(t.li,{children:"the switches"}),"\n",(0,i.jsx)(t.li,{children:"the built in 50 MHz clock"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The outputs will be the six seven-segment displays on the board and a buzzer. Two digits are the minutes, two digits are the seconds, and two digits are hundredths of a second."}),"\n",(0,i.jsxs)(t.p,{children:["For example, 103325 would be 10 minutes and 33.25 seconds. ",(0,i.jsx)(t.em,{children:"(Hint: This means that you\u2019ll need digits in base 6 as well as base 10.)"})]}),"\n",(0,i.jsx)(t.p,{children:"The design will be as follows:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["When the start/stop button is pressed, the timer should toggle between ",(0,i.jsx)(t.strong,{children:"running"})," and ",(0,i.jsx)(t.strong,{children:"being paused"}),".","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Remember! Our buttons are ",(0,i.jsx)(t.strong,{children:"active low"})," \u2013 when they\u2019re not pressed, their output is ",(0,i.jsx)(t.strong,{children:"high"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"When running, the clock should be counting down, and this should show up on the display as well."}),"\n",(0,i.jsx)(t.li,{children:"When paused, the display should remain at whatever time the display showed when it was first paused."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.li,{children:"The rightmost switch will be a speed switch that, when enabled, runs the alarm clock down twice as fast."}),"\n",(0,i.jsx)(t.li,{children:"The remaining nine switches will be used to control the starting time on the clock when it\u2019s being set."}),"\n",(0,i.jsx)(t.li,{children:"When the reset button is pressed, the timer should deactivate and return to the starting value as determined by the switches."}),"\n",(0,i.jsxs)(t.li,{children:["The output digits should be displayed on the seven-segment displays, and you can simply ",(0,i.jsx)(t.strong,{children:"modify your modules from lab 1"}),".","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Note that unlike in lab 1, certain digits can only be from ",(0,i.jsx)(t.strong,{children:"0 to 5"})," instead of the usual ",(0,i.jsx)(t.strong,{children:"0 to 9"})," (so you\u2019ll have to modify your code to reflect that)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.li,{children:"When the alarm clock runs down to zero, the buzzer should activate at an audible frequency of your choice."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"So how do we get started?"}),"\n",(0,i.jsx)(t.h3,{id:"21-the-block-diagram",children:"2.1 The Block Diagram"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"This section does not require writing any code. Read it and move onto the next part before writing any Verilog."})}),"\n",(0,i.jsxs)(t.p,{children:["We\u2019re going to provide you with a block diagram for the alarm clock. A block diagram is essentially a bird\u2019s-eye view of all the modules in the stopwatch and how they go together. This is a simplified version, i.e. not everything is connected up and ",(0,i.jsx)(t.strong,{children:"the buzzer is missing"})," \u2013 if it were complete, you wouldn\u2019t have very much to figure out yourself :-)"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"A semi-complete block diagram of an alarm clock, with each block representing a module. The first module, &quot;clockDivider,&quot; is clocked by the 50 megahertz clock from the FPGA, takes in a speed switch as input, and outputs a new clock at the desired speed. This divided clock becomes the clock for the alarmController module, which also takes in the buttons as input. The output of this module goes into the alarmClock top module, which contains the seven segment display and seven segment digit modules. The alarmClock top module outputs six buses that go into the FPGA&#39;s seven segment displays.",src:n(8104).Z+"",width:"1277",height:"412"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Each rectangle is a \u201cblock,\u201d or a module with the given name. (You can choose your own names if you\u2019d like.)"}),"\n",(0,i.jsxs)(t.li,{children:["The wires coming from within ",(0,i.jsx)(t.code,{children:"FPGA"})," are pins on the FPGA that you will route into your top level module, ",(0,i.jsx)(t.code,{children:"alarmClock_top"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Ports coming out of the smaller modules will need to be declared as wires and driven by the output of that module. For example, you\u2019ll need a wire driven by the output of ",(0,i.jsx)(t.code,{children:"clockDivider"})," that gets routed as an input into ",(0,i.jsx)(t.code,{children:"alarmController"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"A little triangle at the bottom of a module indicates that the module is sequential and uses the wire going into the triangle as a clock. For example, our clock divider is clocked on the FPGA\u2019s own 50 MHz clock pin."}),"\n",(0,i.jsxs)(t.li,{children:["A wire with a line through it indicates that that wire is made up of many bits. These multi-bit wires are formally known as ",(0,i.jsx)(t.em,{children:"buses"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"22-the-finite-state-machine",children:"2.2 The Finite State Machine"}),"\n",(0,i.jsx)(t.p,{children:"It\u2019s time to make a finite state machine of our own! Yay!"}),"\n",(0,i.jsx)(t.p,{children:"First, we have to design it. This entails drawing the diagram with the circles and arrows. We\u2019ll give you a description of the states, their transitions, and how they affect the outputs; and it\u2019ll be up to you to figure out how to put the pieces together."}),"\n",(0,i.jsx)(t.p,{children:"Here are a few quick hints for you when you\u2019re designing your FSM."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["There are three values in this system that will trigger state transitions: the ",(0,i.jsx)(t.strong,{children:"pause/start button"}),", the ",(0,i.jsx)(t.strong,{children:"reset button"}),", and the ",(0,i.jsx)(t.strong,{children:"time remaining"})," on the alarm clock. You do not need a state transition triggered by any other input."]}),"\n",(0,i.jsx)(t.li,{children:"Remember the strategy we discussed in lecture for reading the edge of an external input, like a button or an external clock? You\u2019ll need to apply that here!"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Last note: FSMs are scary! If you need help or can\u2019t figure out how to piece it all together, please reach out to us \u2013 we\u2019re happy to provide a few more hints!"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"SET"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["In this state, ",(0,i.jsx)(t.strong,{children:"9 switches"})," (don\u2019t include the clock speed switch!) can be used to manually adjust the ",(0,i.jsx)(t.strong,{children:"time remaining"})," on the clock.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The switches can be treated as one 9-bit number, with the binary representation of the switches indicating the number of seconds (NOT the hundredths of a second)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["If the user presses the **pause/start button, **the alarm clock should start ",(0,i.jsx)(t.strong,{children:"RUN"}),"ning."]}),"\n",(0,i.jsxs)(t.li,{children:["If the user presses the ",(0,i.jsx)(t.strong,{children:"reset button,"})," nothing should happen, i.e. the alarm clock should stay in this state."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"RUN"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"During this state, changing the switches should not impact the timer."}),"\n",(0,i.jsxs)(t.li,{children:["The time remaining should count down every second or half a second, depending on the speed of the alarm clock as indicated by the speed switch.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Note that this doesn\u2019t mean the speed switch has to be an input to the FSM! You can accomplish this just as easily by having the"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["If the user presses the ",(0,i.jsx)(t.strong,{children:"pause/start button,"})," then the timer should be ",(0,i.jsx)(t.strong,{children:"PAUSE"}),"d."]}),"\n",(0,i.jsxs)(t.li,{children:["If the user presses the ",(0,i.jsx)(t.strong,{children:"reset button,"})," the timer should be re",(0,i.jsx)(t.strong,{children:"SET"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["If the time remaining reaches zero, the alarm clock should start ",(0,i.jsx)(t.strong,{children:"BEEP"}),"ing."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"PAUSE"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["During this state, the timer should not count down, and the display should flash the paused time.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"It\u2019s up to you what frequency the flash is, however, please make sure the flash is discernible."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["If the user presses the ",(0,i.jsx)(t.strong,{children:"stop/start button,"})," the timer should resume ",(0,i.jsx)(t.strong,{children:"RUN"}),"ning."]}),"\n",(0,i.jsxs)(t.li,{children:["If the user presses the ",(0,i.jsx)(t.strong,{children:"reset button,"})," the timer should be re",(0,i.jsx)(t.strong,{children:"SET"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"BEEP"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["During the ",(0,i.jsx)(t.strong,{children:"BEEP"})," state, the buzzer beeps, and the display flashes at 00:00:00 to show that the timer has finished.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"In the event that you are hearing-challenged like I (Claire) am, this buzzer is barely audible. You need to really lean close to hear it, and even then, I still couldn\u2019t hear it :("}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.li,{children:"If the user presses the **stop/start button, **nothing happens."}),"\n",(0,i.jsxs)(t.li,{children:["If the user presses the reset** button,** the timer should be re",(0,i.jsx)(t.strong,{children:"SET"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Remember: For finite state machines, the next state should be computed ",(0,i.jsx)(t.strong,{children:"combinationally"})," based on the current state (and sometimes the inputs), but the actual state change event should be ",(0,i.jsx)(t.strong,{children:"sequential"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"3-its-about-time",children:"3 It\u2019s About Time"}),"\n",(0,i.jsxs)(t.p,{children:["Now that you have the finite state machine drawn out and the buzzer set up, it\u2019s time to code it! Refer to the ",(0,i.jsx)(t.a,{href:"#2-1-the-block-diagram",children:"block diagram in 2.1"}),". You already made your clock divider and you have seven-segment digits from Lab 1. In this part of the lab, you need to write your top level module ",(0,i.jsx)(t.code,{children:"alarmClock_top"})," \u2013 which merely declares input/output ports and wires the other modules together \u2013 and your ",(0,i.jsx)(t.code,{children:"alarmController"}),". The ",(0,i.jsx)(t.code,{children:"alarmController"}),", of course, will be your FSM module \u2013 you should write the Verilog code for your FSM as you designed it in section 2."]}),"\n",(0,i.jsx)(t.h3,{id:"31-implementing-an-fsm",children:"3.1 Implementing an FSM"}),"\n",(0,i.jsxs)(t.p,{children:["Here\u2019s a quick primer on how to implement an FSM in Verilog. ",(0,i.jsx)(t.strong,{children:"The following code blocks are examples with arbitrary state transitions, state names, and outputs; only the overall code structure is relevant and not the values or names themselves."})]}),"\n",(0,i.jsxs)(t.p,{children:["Your module will need to have two ",(0,i.jsx)(t.code,{children:"always"})," blocks: one sequential (clocked) and one combinational. In the sequential block, you should capture the edges of any unsynchronized values, set your outputs, and execute state transitions."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-verilog",children:"input button;\noutput reg [1:0] outVal;\n\nreg [1:0] button_sr;\nreg [1:0] currentState;\nreg [1:0] nextState; // the next state to be assigned\nreg [1:0] outVal_d;  // the next output value to be assigned\n\nalways @(posedge clk) begin\n    /* shift the shift register left by 1 and\n    store the current button value */\n    button_sr <= { button_sr[0], button }\n\n    /* state transition */\n    currentState <= nextState;\n\n    /* output assignment */\n    outVal <= outVal_d;\nend\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In the combinational block, you determine the next state depending on your current state, your inputs, and any other values. You also determine the \u201cnext\u201d output value to be assigned on the next clock cycle. Remember to use ",(0,i.jsx)(t.code,{children:"localparams"})," to give your state values actual labels! It helps make your code more readable."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-verilog",children:"localparam STATE1 = 2'b00;\nlocalparam STATE2 = 2'b01;\n/* other states go here */\n\nalways_comb begin\n    case (currentState)\n        STATE1: begin\n            /* remember that this won't be \"assigned\"\n            until the sequential block executes on\n            the clock edge! */\n\n            /* if the button has a positive edge (i.e.\n            it was just pressed, transition states */\n            if (button_sr == 2'b01) begin\n                nextState = STATE2;\n                outVal_d = 2'b01;\n            end else begin\n                nextState = STATE1;\n                outVal_d = 2'b11;\n            end\n        end\n        /* other states go here */\n    endcase\nend\n"})}),"\n",(0,i.jsx)(t.p,{children:"Just one more tip: for the display flashing, you don\u2019t need a separate state or state machine (apart from BEEP)! Think about whether or not you could use bit tricks to override what the display is showing."}),"\n",(0,i.jsx)(t.p,{children:"Happy coding, and don\u2019t forget to pin plan!"})]})}function c(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8104:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/image1-0a7458d4785daf50017d31ee57ac98ef.png"},3325:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/image2-17b21f2a1a2830acea7b868ac126224d.png"},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>r});var i=n(7294);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);