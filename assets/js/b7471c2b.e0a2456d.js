"use strict";(self.webpackChunkprojects_ieeebruins_com=self.webpackChunkprojects_ieeebruins_com||[]).push([[715],{1258:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>n,metadata:()=>r,toc:()=>h});var i=t(5893),l=t(1151);const n={sidebar_position:10},s="Floodfill Module",r={id:"micromouse/floodfill-module",title:"Floodfill Module",description:"Overview",source:"@site/docs/micromouse/floodfill-module.md",sourceDirName:"micromouse",slug:"/micromouse/floodfill-module",permalink:"/micromouse/floodfill-module",draft:!1,unlisted:!1,editUrl:"https://github.com/UCLA-IEEE/projects.ieeebruins.com/tree/main/docs/micromouse/floodfill-module.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"docsSidebar",previous:{title:"IR Code Module",permalink:"/micromouse/ir-code-module"},next:{title:"Q&A",permalink:"/micromouse/q-and-a"}},a={},h=[{value:"Overview",id:"overview",level:2},{value:"Floodfill Lecture",id:"floodfill-lecture",level:2},{value:"Simulation Setup",id:"simulation-setup",level:2},{value:"Simulator Notes",id:"simulator-notes",level:2},{value:"Implementing Floodfill",id:"implementing-floodfill",level:2}];function d(e){const o={a:"a",h1:"h1",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,l.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.h1,{id:"floodfill-module",children:"Floodfill Module"}),"\n",(0,i.jsx)(o.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(o.ol,{children:["\n",(0,i.jsx)(o.li,{children:(0,i.jsx)(o.a,{href:"#heading=h.69qwjk4w5wc4",children:"Floodfill Lecture"})}),"\n",(0,i.jsx)(o.li,{children:(0,i.jsx)(o.a,{href:"#heading=h.2suvr82y3f4z",children:"Simulation Setup"})}),"\n",(0,i.jsx)(o.li,{children:(0,i.jsx)(o.a,{href:"#heading=h.1vr7qet6ko0l",children:"Implementing Floodfill"})}),"\n",(0,i.jsx)(o.li,{children:(0,i.jsx)(o.a,{href:"#heading=h.1zmi9tmv6nd5",children:"Implementation Tips"})}),"\n"]}),"\n",(0,i.jsx)(o.p,{children:"In this software filled lecture, we will walk you through the floodfill maze solving algorithm. Please make sure you really understand how this algorithm works, as you will be creating your own later in the module. With this final step, your mouse should be good to compete in a micromouse competition!"}),"\n",(0,i.jsxs)(o.p,{children:["If you're stuck or want to make sure you're on the right track, you can find one implementation of floodfill ",(0,i.jsx)(o.a,{href:"https://drive.google.com/drive/folders/1_6d2o_yjViv5TPkr-vZGpg-Ce6-iYRiE?usp=sharing",children:"here"}),". Keep in mind that this isn't the only way to make your algorithm!"]}),"\n",(0,i.jsx)(o.h2,{id:"floodfill-lecture",children:"Floodfill Lecture"}),"\n",(0,i.jsx)(o.p,{children:"So far, you have created your mouse schematic, created your mouse, got the motors to move, and implemented the IR sensors. You\u2019ve come a long way! Congratulations! Your mouse is almost complete. The last thing needed to get your mouse to actually solve the maze is coding the algorithm that will help your mouse navigate through the 16x16 maze during a competition. You will do so by implementing the floodfill algorithm for your mouse."}),"\n",(0,i.jsx)(o.p,{children:"Before continuing on with the rest of this module, please make sure you watch the floodfill lecture below. This will give you a good conceptual understanding of the algorithm and will help you immensely while creating your code."}),"\n",(0,i.jsx)(o.h2,{id:"simulation-setup",children:"Simulation Setup"}),"\n",(0,i.jsx)(o.p,{children:"It would be incredibly impractical to try coding the floodfill algorithm directly onto your mouse\u2026 testing it would be incredibly tedious as you would have to continuously upload your code to the mouse, and send your mouse through the maze every time you make a small change to the code. Instead, use this micromouse simulation that will model the mouse through the maze, and allow you to virtually test your algorithm to make sure it works!"}),"\n",(0,i.jsx)(o.p,{children:"For Windows:"}),"\n",(0,i.jsx)(o.p,{children:(0,i.jsx)(o.a,{href:"https://docs.google.com/presentation/d/1tr_2cUcouLl3fvlSyOth7XXo3jRbpBw1TfRX8yWRETY/edit?usp=sharing",children:"Follow these instructions"})}),"\n",(0,i.jsx)(o.p,{children:"For MacOS / Linux:"}),"\n",(0,i.jsx)(o.p,{children:(0,i.jsx)(o.a,{href:"https://docs.google.com/presentation/d/18rHwcIJNPsIRkun7N9Wq5YYAiFSc-rkyNcAQBOEolg4/edit?usp=share_link",children:"Follow these instructions"})}),"\n",(0,i.jsx)(o.p,{children:"Once you finish setting up, you will use your solver.c and solver.h files to implement Floodfill."}),"\n",(0,i.jsx)(o.h2,{id:"simulator-notes",children:"Simulator Notes"}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsxs)(o.li,{children:["The API for the simulator can be found at ",(0,i.jsx)(o.a,{href:"https://github.com/mackorone/mms#mouse-api",children:"https://github.com/mackorone/mms#mouse-api"}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"When you eventually port this algorithm to your Mouse, you\u2019ll have to replace the API calls with your own functions that read the IRs!"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(o.li,{children:["The reset button does not work for the skeleton files, and is extra work to implement. Feel free to implement it yourself if you desire.","\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"Instead, you can just hit the Cancel button to restart the simulation."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(o.li,{children:["Designing your own maps is simple! More info can be found at the ",(0,i.jsx)(o.a,{href:"https://github.com/mackorone/mms#maze-files",children:"github repository."})]}),"\n",(0,i.jsxs)(o.li,{children:["Your program can print to the debug log by printing to stderr in any way you\u2019d like. Here are some methods:","\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"debug_log( <string> ); This is a function provided by the API in API.c"}),"\n",(0,i.jsxs)(o.li,{children:["fprintf( stderr, \u201cprintf %d\u201d, <int> ); Prints to stderr using ",(0,i.jsx)(o.a,{href:"https://www.cplusplus.com/reference/cstdio/printf/",children:"printf formatting"}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"Note that if you run fprintf( stderr ), you should run fflush(stderr); directly after it to clear the output buffer"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(o.h2,{id:"implementing-floodfill",children:"Implementing Floodfill"}),"\n",(0,i.jsx)(o.p,{children:(0,i.jsxs)(o.strong,{children:["Here\u2019s the ",(0,i.jsx)(o.a,{href:"https://drive.google.com/drive/folders/12Jk35q7irAqO6b6fU7UQnhUcyCelNV2E?usp=share_link",children:"link"})," to the code templates to help you get started!"]})}),"\n",(0,i.jsxs)(o.p,{children:["Edit the solver.h and solver.c files to implement your Floodfill algorithms. You can edit in a text editor of your choice instead of STM32CubeIDE, since the simulator code is completely independent of your Rat code. If you don\u2019t have another one, ",(0,i.jsx)(o.a,{href:"https://code.visualstudio.com/",children:"VS Code"})," is a good choice. You should only add a declaration for your floodfill function (and any other helping functions) to solver.h. In solver.c, implement your Floodfill algorithm! Note that the solver() function is different from the function in which you will implement your Floodfill algorithm, as it is simply a forwarding function that the simulator calls to retrieve the correct maze solving algorithm. The solver() function should simply call the floodfill function that you define and do nothing else."]}),"\n",(0,i.jsx)(o.p,{children:"It may be helpful to review the slides or recording of the Floodfill lecture. Additionally, here is the pseudocode for recalculating Manhattan distances using Floodfill:"}),"\n",(0,i.jsxs)(o.ol,{children:["\n",(0,i.jsx)(o.li,{children:"Set all cells except goal to \u201cblank state\u201d"}),"\n",(0,i.jsx)(o.li,{children:"Set goal cell(s) value to 0 and add to queue"}),"\n",(0,i.jsxs)(o.li,{children:["While queue is not empty:","\n",(0,i.jsxs)(o.ol,{children:["\n",(0,i.jsx)(o.li,{children:"Take front cell in queue \u201cout of line\u201d for consideration"}),"\n",(0,i.jsxs)(o.li,{children:["Set all ",(0,i.jsx)(o.strong,{children:(0,i.jsx)("ins",{children:"blank"})})," and ",(0,i.jsx)(o.strong,{children:(0,i.jsx)("ins",{children:"accessible neighbors"})})," to front cell\u2019s value + 1"]}),"\n",(0,i.jsx)(o.li,{children:"Add cells we just processed to the queue"}),"\n",(0,i.jsx)(o.li,{children:"Else, continue!"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(o.p,{children:"Also note that this assignment is done in C rather than C++ because the code for your mice is written in C. This means that you can\u2019t use the fancy C++ tools like classes, objects, constructors and templates. So, if you want to use a stack or a queue, you need to implement your own queue or stack. You might want to refresh your knowledge on C structs! :)"}),"\n",(0,i.jsx)(o.h1,{id:"implementation-tips",children:"Implementation Tips"}),"\n",(0,i.jsx)(o.p,{children:"You will need a coordinate system as a way to denote each cell in the maze given a row and column (as well as a reference point)."}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"Defining a data type using a struct to will make these coordinates easier to keep track of"}),"\n"]}),"\n",(0,i.jsx)(o.p,{children:"You will also need a way to store the locations of known walls as well as currently calculated Manhattan distances"}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"It\u2019s probably easiest to have three 2D arrays: one for horizontal walls, one for vertical walls, and one for Manhattan distances"}),"\n"]}),"\n",(0,i.jsxs)(o.p,{children:["To help with your sanity, we recommend using the features provided by the simulator\u2019s ",(0,i.jsx)(o.a,{href:"https://github.com/mackorone/mms#mouse-api",children:"API"}),". The biggest recommendation we have is to use the API to"]}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"Display Manhattan distances in each cell"}),"\n",(0,i.jsx)(o.li,{children:"Set/Light up walls that you have discovered"}),"\n",(0,i.jsx)(o.li,{children:"Display or Mark any other useful debugging information!"}),"\n"]}),"\n",(0,i.jsx)(o.p,{children:(0,i.jsx)(o.img,{alt:"alt_text",src:t(9591).Z+"",title:"image_tooltip",width:"900",height:"898"})}),"\n",(0,i.jsx)(o.p,{children:"Of course, you will have to remove these functions later when you transfer your solver code to the microcontroller, but they will be very helpful for now!"}),"\n",(0,i.jsx)(o.p,{children:"You need to make sure you initialize all your variables correctly. This means that you should initialize all your walls to be empty before you calculate your initial Manhattan Distances"}),"\n",(0,i.jsx)(o.p,{children:"There are a few different ways to implement your queue; the one we recommend is a circular array. We talked a bit about it in lecture, and there are numerous resources online that might be helpful too."}),"\n",(0,i.jsxs)(o.ul,{children:["\n",(0,i.jsx)(o.li,{children:"When choosing the size for your array, make sure it can hold the complete list of accessible cells. For a 16x16 maze, 512 should be more than sufficient."}),"\n",(0,i.jsx)(o.li,{children:"C does not have the STL library that many of you might be familiar with from C++ (since templates don\u2019t exist in C), which is why we are implementing our own queue"}),"\n"]}),"\n",(0,i.jsx)(o.h1,{id:"bonus-challenge",children:"Bonus Challenge"}),"\n",(0,i.jsx)(o.p,{children:"Once you are finished and have the mouse successfully finding its way to the center of the maze, try having the mouse move from the center back to the starting position! The idea is that the mouse will try a new path on the way back that is potentially faster, and on its way it will gain new information about the nearby walls. One strategy for finding the optimal path is to have the mouse keep going back and forth between the starting position and the center because with each run it will try a new potentially faster path until the fastest is found."}),"\n",(0,i.jsx)(o.p,{children:"Implementing this should be fairly straightforward. Once you reach the center, simply recalculate Floodfill and set the starting position as the goal cell, and the same Floodfill algorithm will work. Getting this working now will save you time later on and get you more prepared for AAMC!"}),"\n",(0,i.jsxs)(o.p,{children:["If you would like to try other mazes as well, we have a ",(0,i.jsx)(o.a,{href:"https://drive.google.com/drive/folders/1rrAo9fEn9-vTskAARHAtY_kaurIqwsau?usp=sharing",children:"folder of old mazes"})," from past competitions as well."]})]})}function u(e={}){const{wrapper:o}={...(0,l.a)(),...e.components};return o?(0,i.jsx)(o,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},9591:(e,o,t)=>{t.d(o,{Z:()=>i});const i=t.p+"assets/images/image1-c46ff173c4d8e7101bdf1f6a15e8aef3.png"},1151:(e,o,t)=>{t.d(o,{Z:()=>r,a:()=>s});var i=t(7294);const l={},n=i.createContext(l);function s(e){const o=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),i.createElement(n.Provider,{value:o},e.children)}}}]);